import re
import requests # pip3 install requests --break-system-packages

# INPUTS
# You usually will receive the domain list to block on a PDF file. Copy it to a excel
# file and make sure all domains are in the same cell, then copy it to the domains.txt file.
# Don't mind with empty lines or undesired data (eg. pdf pagination or table headers) in the file as this
# script will try to clean it all.

# The file with a list of domains unformated (eg. many domains on the same line, 
# or Texts that aren't domains - don't have a dot ".")
unformatedDomainList = './domains.txt'

# The output file generated by this script in which should be used by add-domains-to-block.py
outputBlacklistFile = './domainsToBlock.txt'

# Get a list of all valid TLD (Top Level Domains)
URL="https://data.iana.org/TLD/tlds-alpha-by-domain.txt"
def getAllTLDDomains():
    response = requests.get(URL)
    domains = []
    if(response.status_code == 200):
        rs = response.text.split('\n')
        #print(rs)
        for line in rs:
            if not line.startswith("#") and line != "":
                domains.append(line)
    return domains

# List of all TLDs got from IANA.org
topLevelDomainList = getAllTLDDomains()

# Checks if the string read from the input file is a valid domain
def testValidDomain(stringToTest):
    if any(tld.lower() in stringToTest.lower() for tld in topLevelDomainList):
        #print(" {} is a valid domain".format(stringToTest.lower()))
        return True
    #print(" {} is NOT a valid domain".format(stringToTest.lower()))
    return False

# Return only the validated domains
def returnOnlyValidDomains(fileWithStringsToTest):
    domainList = []
    for line in fileWithStringsToTest:
        # Split words by a space as some lines may have more than one domain
        for word in line.split(" "):
            # Remove "/" from the string
            word = word.split("/")[0]
            # Checks if it is an e-mail address instead of a domain (e-mail address on footer of the document)
            atFound = re.findall(r'\@', word)
            if atFound:
                print("E-mail found: {}".format(word))
                continue
            # Checks if the word has a dot "." in the mid (ignoring the possibility of the word 
            # ending with dot to avoid the paginator being considered a domain (pg.)). All domains should(?).
            dotFound = re.findall(r'\.', word[:-1].lower())
            if not dotFound:
                #print("Word: {}, DotFound: {}".format(word, dotFound))
                continue
            else:
                domain = word.lower().split()[0]
                #print("Word: {}, DotFound: {}, Domain: {}".format(word, dotFound, domain), end="")
            
            # Checks if the word ends with one of the TLD (Top Level Domains). All domains should.
            if not testValidDomain(domain):
                continue


            # if it is a domain, add to a validated domain list
            domainList.append(domain)
    return domainList

# Read the INPUT file in which we will filter only valid domains
def readFromInputFile(inputFile):
    domainList = list()
    file = open(inputFile, 'r')
    domainList = returnOnlyValidDomains(file)
    return domainList

# Write the valid domains to output file
def writeToBlacklistFile(domainList, outputBlacklistFile):
    file = open(outputBlacklistFile, 'w')
    for domain in domainList:
        file.write('{0}\n'.format(domain))
    file.close()
    print("Writed {} domains to {}".format(len(domainList), outputBlacklistFile))

domains = readFromInputFile(unformatedDomainList)
writeToBlacklistFile(domains, outputBlacklistFile)